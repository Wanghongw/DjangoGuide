<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>01 路由控制 - Django使用指南</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "01 \u8def\u7531\u63a7\u5236";
    var mkdocs_page_input_path = "Django\u6838\u5fc3/\u8def\u7531.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Django使用指南</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../Django框架入门/">Django框架入门</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Django核心知识点详解</span>
    <ul class="subnav">
                <li class=" current">
                    
    <a class="current" href="./">01 路由控制</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#_1">分组的概念</a></li>
    

    <li class="toctree-l3"><a href="#_2">路由给视图传参的另外一种方式</a></li>
    

    <li class="toctree-l3"><a href="#_3">路由分发</a></li>
    

    <li class="toctree-l3"><a href="#_4">反向解析</a></li>
    

    <li class="toctree-l3"><a href="#_5">处理带参数的反向解析</a></li>
    

    <li class="toctree-l3"><a href="#_6">名称空间</a></li>
    

    <li class="toctree-l3"><a href="#_7">实际开发中名称空间不能重名</a></li>
    

    <li class="toctree-l3"><a href="#path">path方法</a></li>
    

    <li class="toctree-l3"><a href="#path-converters">path converters</a></li>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../视图系统/">02 视图系统</a>
                </li>
                <li class="">
                    
    <a class="" href="../模型层/">03 模型层</a>
                </li>
                <li class="">
                    
    <a class="" href="../模板层/">04 模板层</a>
                </li>
                <li class="">
                    
    <a class="" href="../中间件/">05 中间件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Django中常用的组件介绍</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Django组件/Django中contenttypes组件的使用/">contenttypes组件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Django进阶及其他知识点汇总</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../Django进阶/ORM语句的优化/">ORM语句的优化</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">DRF相关</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../DRF相关/认证、权限及访问频率限制/">认证、权限及访问频率限制简介</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">web开发常识</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../123/">123</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Django使用指南</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Django核心知识点详解 &raquo;</li>
        
      
    
    <li>01 路由控制</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>当前端请求经过WSGI与中间件的处理后，到达Django的url控制器进行路径匹配。如果路径匹配成功url控制器会指定对应的视图函数进行逻辑处理，如果路径匹配不成功会返回<code>404错误</code>给前端。</p>
<h3 id="_1">分组的概念</h3>
<p>路由控制器中通过<code>分组</code>将url匹配到的数据传给视图函数处理。</p>
<p>Django路由控制器中的分组包括<code>无名分组</code>与<code>有名分组</code>。</p>
<p><strong>无名分组</strong></p>
<p>像这种形式的路由匹配的格式就是无名分组：</p>
<pre><code class="python">re_path(r'^articles/([0-9]{4})/([0-9]{2})/$',views.month_archive)
</code></pre>

<p>需要注意的一点是：如果使用无名分组去获取url中的数据，视图函数中的参数是有顺序的，视图函数中参数的顺序就是传入参数的顺序：</p>
<pre><code class="python"># 第一个参数永远是request
# year接收的是[0-9]{4}这个规则匹配到的数据，month接收的是[0-9]{2}这个规则匹配到的数据
def month_archive(request,year,month):
    print(year) 
    print(month)
    xxx
</code></pre>

<p><strong>有名分组</strong></p>
<p>使用有名分组的方式如下：</p>
<pre><code class="python">re_path(r'^articles/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$',views.month_archive)
</code></pre>

<p>使用有名分组的话视图函数接收参数的时候只需要指定对应变量的名字就好了：</p>
<pre><code class="python"># 不管year与month的位置怎么变，month永远拿到的是([0-9]{2})匹配到的数据，
# year永远拿到的是([0-9]{4})匹配到的数据
def month_archive(request,month,year):
    print(year) 
    print(month)
    xxx
</code></pre>

<h3 id="_2">路由给视图传参的另外一种方式</h3>
<p>之前做项目的时候发现路由还可以通过这种方式给视图传参：</p>
<pre><code class="python">re_path('^index/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$',views.index,{&quot;name&quot;:&quot;whw&quot;,&quot;age&quot;:18}),
</code></pre>

<p>访问:</p>
<pre><code class="python">http://127.0.0.1:8001/index/2000/12
</code></pre>

<p>视图函数中的情况如下：</p>
<pre><code class="python">def index(request,name,age,month,year):

    print(month) # 12
    print(year)  # 2000
    print(name) # whw
    print(age)  # 18
    xxx
</code></pre>

<h3 id="_3">路由分发</h3>
<p>路由的分发其实相当于程序的<code>解耦</code>，将不同应用的路由写在自己的app里面就好了，项目的<code>总路由</code>只负责将不同应用的url<code>分发</code>到相应的应用中即可。</p>
<p>假设我们在项目中创建了一个名为<code>blog</code>的应用，在这个app中创建一个<code>urls.py</code>文件作为应用分发的路由。</p>
<p>我们需要在与项目同名的那个目录的urls.py文件中做一下分发：</p>
<pre><code class="python">#引入include
from django.urls import path,re_path,include

#在urlpatterns列表中加下面这段“分发”的代码：
#写法一：
#如果这样写的话，我们在访问的时候是这样的:http://127.0.0.1:8000/blog/login/
#也就是说，想要访问blog的内容 http://127.0.0.1:8000/blog/ 是必不可少的
#注意这里blog后面的'/'必须得加
re_path(r'blog/',include('blog.url')

#写法二：
#但是如果我们这样写，访问blog里的代码就不用加blog了：http://127.0.0.1:8000/login/
#注意这里^后面不加‘/’
re_path(r'^',include('blog.urls'))
</code></pre>

<p>在blog应用中的urls.py中加入自己的路由匹配：</p>
<pre><code class="python">#将之前全局的有关blog里面的views.py文件的函数的操作都放到blog里的urls.py文件中：
from django.urls import path,re_path
from blog import views

urlpatterns = [
    path('login/',views.login),
    #路由配置————哪一个路径由哪一个视图函数去处理
    #调用的时候会自动传一个request参数，如special_case_2003(request)
    re_path(r'^articles/2003/$',views.special_care_2003),
    #下面的效果跟上面一样，只不过是正则表达式的匹配方式不同，需要的函数还是写在blog的views.py文件中
    # 注意这一个，有分组的话需要在views.py文件的相应的函数中多加一个参数：
    re_path(r'^articles/([0-9]{4})/$',views.year_archive),
    #有两个分组需要在views.py的相应的函数中多加两个参数：
    re_path(r'^articles/([0-9]{4})/([0-9]{2})$',views.month_archive),
    #有名分组
    re_path(r'^articles/(?P&lt;str_2&gt;[a-z]{2})/(?P&lt;str_1&gt;[a-z]{1})/$',views.str_name1)
]
</code></pre>

<h3 id="_4">反向解析</h3>
<p>当前端模板（提交请求）与视图逻辑（做重定向）需要用到传来的url时，将整个url当作参数并不是很方便。我们可以在路由中为每条url设置<code>别名</code>，其他地方需要使用这条url时只需要使用这个别名就可以了，这就是反向解析的作用。</p>
<p>路由中<code>设置别名</code>的方法 —— 只需要在视图的后面加上<code>name=别名</code>即可</p>
<pre><code class="python">re_path('^login/$',views.login,name=&quot;login&quot;),
re_path('^index/$',views.index,name=&quot;index&quot;),
</code></pre>

<p><strong>反向解析在视图中的使用</strong></p>
<p>基本都是做重定向用的：</p>
<pre><code class="python">from django.shortcuts import render,redirect


def index(request):
    xxx

    # 逻辑处理失败后重定向到登录页面
    return redirect(&quot;login&quot;)

</code></pre>

<p><strong>视图中处理不带分组的路由别名</strong></p>
<p>当然视图中也可以<code>通过别名找到传过来的url</code>:</p>
<p>路由为：</p>
<pre><code class="python">re_path(r'^articles/2003/$',views.special_care_2003,name='s_c_2003'),
</code></pre>

<p>对应的视图：</p>
<pre><code class="python"># 引入reverse
from django.urls import reverse    

def special_care_2003(request):
    url = reverse('s_c_2003')
    print(url)#前面设置的路由  /articles/2003/
    return HttpResponse('哈哈! 2003')
</code></pre>

<p><strong>视图中处理带分组的路由别名</strong></p>
<p>分组的路由为：</p>
<pre><code class="python">re_path('^index/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$',views.index,name=&quot;index&quot;),
</code></pre>

<p>视图处理逻辑：</p>
<pre><code class="python">from django.urls import reverse

def index(request,month,year):

    print(month) # 12
    print(year)  # 2000
    # 有分组的reverse的用法！
    url = reverse(&quot;index&quot;, args=(year,month))
    print(url) # /index/2000/12/
    xxx
</code></pre>

<p><strong>反向解析在模板中的使用</strong></p>
<p>我们做一个简单的登陆逻辑，路由如下</p>
<pre><code class="python">re_path('^login/$',views.login,name=&quot;LOG&quot;),
</code></pre>

<p>模板文件如下</p>
<pre><code class="python">&lt;form action=&quot;{% url 'LOG' %}&quot; method=&quot;post&quot;&gt;
    {# csrf校验 #}
    {% csrf_token %}
    用户名: &lt;input type=&quot;text&quot; name=&quot;user&quot;  &gt;
    密码: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>

<p>其实这里的action指向的是<code>http://127.0.0.1:8000/login/</code>这条路由。</p>
<p><code>{% url '别名' %}</code>是反向解析的语法</p>
<p><strong>反向解析的登陆认证实例</strong></p>
<p>拿上面的登陆路由做一个简单的实例。</p>
<p>还是那条路由：</p>
<pre><code class="python">re_path('^login/$',views.login,name=&quot;LOG&quot;),
</code></pre>

<p>模板中的内容如下：</p>
<pre><code class="python">&lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;Title&lt;/title&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/whw1.css&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;

    &lt;form action=&quot;{% url 'LOG' %} method=&quot;post&quot;&gt;
        用户名: &lt;input type=&quot;text&quot; name=&quot;user&quot;  &gt;
        密码: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;
        &lt;input type=&quot;submit&quot;&gt;
    &lt;/form&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>

<p>视图函数的内容如下：</p>
<pre><code class="python">from django.shortcuts import render, HttpResponse


# 注意这个函数必须要有一个形参 request
def login(request):
    # 如果是GET请求则返回当前页面
    if request.method == 'GET':
        print('GET请求的数据:', request.GET)
        # 这个函数必须得有return，而且是利用render渲染...
        return render(request, 'login.html')

    # 如果是POST请求方式则做校验
    elif request.method == 'POST':
        print('POST请求的数据:', request.POST)
        # 注意：
        # request.POST存的是form表单中name值作为key自己输入的值作为value的字典！
        user = request.POST.get('user')  # 这里的user与form表单中的name值对应
        pwd = request.POST.get('pwd')  # 这里的pwd与form表单中的name值对应
        # 这里可以用数据库操作代替：：：
        if user == 'whw' and pwd == '123':
            return HttpResponse('OK!')
        else:
            return HttpResponse('ERROR!')
</code></pre>

<h3 id="_5">处理带参数的反向解析</h3>
<p>实际中，我们在利用ajax给后台传入一个url时会带着参数。有些小伙伴喜欢用路由解析去给后台传url，所以在a标签中利用反向解析时会这样做：</p>
<pre><code class="python">&lt;a href=&quot;{% url &quot;del_book 1&quot; %}&quot;&gt;删除&lt;/a&gt; 
</code></pre>

<p>这样做完全没问题。</p>
<p><strong>ajax处理的问题</strong></p>
<p>但是，实际项目中常会用到<code>ajax异步操作</code>，如果你在ajax中这样写url的话：</p>
<pre><code class="python">var del_id = $('#del_id').text();
xxx
xxx
url:'{% url &quot;del_book&quot; del_id %}',
</code></pre>

<p>浏览器会给你返回一个这样的错误：路由中拿不到你传的这个参数~</p>
<p><img alt="1" src="../../img/ajax1.png" /></p>
<p>这就说明：<code>在ajax的反向解析中，不可以传一个“变量”</code></p>
<p><strong>解决方案1</strong></p>
<p>可以另辟蹊径，我们可以把需要的路由放在一个标签中，这个标签用模版的反向解析的语法获取到这个路由，然后再传给ajax的url：</p>
<pre><code class="c++">//构建一个获取url的标签
&lt;span id=&quot;del_url&quot; class='hidden'&gt;{% url 'del_book' 1 %}}&lt;/span&gt;
。。。
//用一个变量接收这个路由：/del_book/1/
var u1 = $('#del_url').text();

$.ajax({
        //url用这个变量u1
        url:u1,
        type:'post',
          。。。
})
</code></pre>

<p>但是呢～聪明的你可能一眼就看出问题来了：你这个 1 是一个常量不是变量呀！我想加一个变量怎么办呢？请看方法2:</p>
<p><strong>解决方案2</strong></p>
<p>实际上，我们会通过模板语法去渲染页面~方法1中提到的“常量”其实可以在模板渲染的时候拿到，</p>
<p>既然我们能通过{{  obj.pk  }}值可以获取到这个条目的id值~那可以在这个位置构建一个隐藏的标签：</p>
<pre><code class="python">&lt;span class='hidden'&gt;{% url &quot;index&quot; {{ obj.pk }} %}&lt;/span&gt;
</code></pre>

<p>大家可以看到~这个span标签里存放着不就是我们需要的那个带动态参数的路径吗？接着利用jQuery的选择器拿到这个路径参数。</p>
<pre><code class="python">//假设这个span标签在我们点击的按钮的后面
var id_url = $(this).next().text();
</code></pre>

<p>然后，在url的data中就可以用这个路径了：</p>
<pre><code class="c++">...
$.ajax({
　　url:id_url,
　　...
})
...  
</code></pre>

<p><strong>解决方案3</strong></p>
<p>第三种解决方案是“路径拼接”～特别注意：这里的路径必须是一个全路径！</p>
<pre><code class="python">{# 获取要被删除的书籍的id #}
var del_id = $('#del_id').text();
$.ajax({
    {# 拼接路径 #}
    url:'/book/del_book/' + del_id +'/',
    {#url:'{% url &quot;del_book&quot; del_id %}', //不可以这样写#}
    type:'post',
    。。。
}) 
</code></pre>

<h3 id="_6">名称空间</h3>
<p>上面介绍了反向解析与路由别名的概念，也许聪明的你会提出这样一个问题：如果实际中不同的app的url出现了相同的别名怎么办呢？</p>
<p>Django为我们提供了<code>名称空间</code>解决上面的问题。</p>
<p>这里我做了一个demo为大家详细讲解<code>名称空间的使用</code>。</p>
<p>首先，我们新建一个名为NameSpace的Django项目，然后在里面创建两个应用，分别叫customer与payment，记得在settings中的INSTALLED_APPS中注册这两个应用～</p>
<p>接着，在template目录中分别创建两个项目的模板文件夹～而且让其中的两个网页名字一样，项目的具体结构如下：</p>
<pre><code class="python">.
├── NameSpace   # 与项目同名的目录
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py  # 项目的总路由
│   └── wsgi.py
├── customer   # customer应用
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   ├── urls.py  # customer分路由
│   └── views.py # customer的视图
├── manage.py
├── payment   # payment应用
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   ├── urls.py  # payment分路由
│   └── views.py # payment的视图
└── templates # 模板目录
    ├── customer
    │   └── index.html # customer的index页面
    └── payment
        └── index.html # payment的index页面
</code></pre>

<p><strong>路由分发</strong></p>
<p>全局的urls文件中（跟项目名同名的目录里的文件我习惯叫全局文件）做路由分发：</p>
<pre><code class="python">urlpatterns = [
    path('admin/', admin.site.urls),
    re_path('^customer/',include('customer.urls')),
    re_path('^payment/',include('payment.urls')),
]
</code></pre>

<p><strong>customer目录中新建的urls文件</strong></p>
<pre><code class="python">from django.urls import path,re_path
from customer import  views

urlpatterns = [
    re_path(r'^index/$',views.index,name='index'),
]
</code></pre>

<p><strong>payment目录中新建的urls文件</strong></p>
<pre><code class="python">from django.urls import path,re_path
from payment import views

urlpatterns = [
    re_path(r'^index/$',views.index,name='index'),
]
</code></pre>

<p><strong>视图函数</strong></p>
<p>customer目录中的视图函数</p>
<pre><code class="python">from django.shortcuts import render,HttpResponse
from django.urls import reverse

def index(request):
    if request.method == 'GET':
        url = reverse('index')
        print('customer_url:',url)
        return HttpResponse(url)
</code></pre>

<p>payment目录中的视图函数</p>
<pre><code class="python">from django.shortcuts import render,HttpResponse
from django.urls import reverse

def index(request):
    if request.method == 'GET':
        url = reverse('index')
        print('payment:',url)
        return HttpResponse(url)
</code></pre>

<p><strong>存在问题</strong></p>
<p>大家可以看到：我在两个应用的分发路由中给两个不同的index路径（事实上，我们访问customer的indexs的路径其实是/customer/index/，同理payment的index的路径是/payment/index/）取了相同的别名index；而且在不同的视图函数中通过反向解析拿到了别名index对应的路径打印了出来并返回给浏览器。</p>
<p>现在我们试试实际的运行效果：</p>
<p>当我访问payment的index的时候确实打印出了正确的路径：</p>
<p><img alt="11" src="../../img/名称空间/2.png" /></p>
<p>但是，当我访问customer的路径的时候出错了：这个url竟然被反向解析成了payment的index路径！</p>
<p><img alt="121" src="../../img/名称空间/3.png" /></p>
<p>让我们再来看看后台打印的效果：从第二条数据可以看出来～浏览器明明收到的是customer的get请求，可是反向解析出来的index的路径却是另外一条路由！</p>
<p><img alt="121" src="../../img/名称空间/4.png" /></p>
<p>实际中这样出现这样的问题是十分危险的！为了避免这种情况发生，可以利用<code>名称空间</code>解决。</p>
<p><strong>名称空间解决</strong> </p>
<p>利用名称空间可以解决上面的问题～</p>
<p>首先我们在路由分发的时候为每条分发的路由加上名称空间：</p>
<pre><code class="python">urlpatterns = [
    path('admin/', admin.site.urls),
    # 分发的时候加上名称空间
    re_path('^customer/',include(('customer.urls','customer'))),
    re_path('^payment/',include(('payment.urls','payment'))),
]
</code></pre>

<p>两个应用的分发的路由中的写法还跟上面的一样。</p>
<p>在视图函数中进行反向解析的时候为每个别名加上自己的名称空间。</p>
<p>customer的视图函数：</p>
<pre><code class="python">from django.shortcuts import render,HttpResponse
from django.urls import reverse

def index(request):
    if request.method == 'GET':
        # 反向解析的时候加上名称空间
        url = reverse('customer:index')
        print('customer_url:',url)
        return HttpResponse(url)
</code></pre>

<p>payment的视图函数：</p>
<pre><code class="python">from django.shortcuts import render,HttpResponse
from django.urls import reverse

def index(request):
    if request.method == 'GET':
        url = reverse('payment:index')
        print('payment:',url)
        return HttpResponse(url)

</code></pre>

<p><strong>最后让我们看看结果：</strong></p>
<p>（1）访问payment的结果：</p>
<p><img alt="121" src="../../img/名称空间/5.png" /></p>
<p>（2）访问customer的结果：</p>
<p><img alt="121" src="../../img/名称空间/6.png" /></p>
<p>（3）最后看看打印结果：</p>
<p><img alt="121" src="../../img/名称空间/7.png" /></p>
<h3 id="_7">实际开发中名称空间不能重名</h3>
<p><strong>切记！实际开发中名称空间不能重名！</strong></p>
<h3 id="path">path方法</h3>
<p>Django2版本路由匹配新增了<code>path方法</code>，另外re_path方法与Django1版本的url方法用法完全一致，其实就是正则匹配。</p>
<p>这里着重介绍一下path方法。</p>
<p><strong>path方法解决的问题</strong></p>
<p>（1）对于这样的路由匹配：</p>
<pre><code class="python">re_path('^index/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$',views.index}
</code></pre>

<p>这里的year参数是str类型的。但是实际中如果我们想拿到一个int类型的值的话，还需要进行<code>int(year)</code>的转换。</p>
<p>做这种转换是有风险的，实际中可能会出现<code>TypeError</code>或者<code>ValueError</code>异常，使用path方法我们可以将这种转化在Django内部自动完成。</p>
<p>（2）还是拿上面的路由匹配为例，对于year这个变量，如果三个路由中都有它的话我们得写三遍：</p>
<pre><code class="python">re_path('^index/(?P&lt;year&gt;[0-9]{4})/$',views.index1},
re_path('^index/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/$',views.index2},
re_path('^index/(?P&lt;year&gt;[0-9]{4})/(?P&lt;month&gt;[0-9]{2})/666/$',views.index3}
</code></pre>

<p>而使用path方法只需要做一处修改即可。</p>
<p><strong>使用path方法解决上面问题</strong></p>
<pre><code class="python">rom django.urls import path,re_path
from blog import views

urlpatterns = [
    re_path('^login$/',views.login,name='LOGIN'),
    # 有名分组
    re_path('^articles/(?P&lt;y&gt;[0-9]{4})/(?P&lt;m&gt;[a-zA-Z0-9]+$)',views.get_y_m),
    ### path方法
    #这里的int是内置的转换器
    path('articles/&lt;int:year&gt;/&lt;int:month&gt;/',views.get_year_month),

    ]
</code></pre>

<p>对应的视图函数如下：</p>
<pre><code class="python">from django.shortcuts import render,HttpResponse
# Create your views here.
def login(request):
    if request.method == 'GET':
        return render(request,'login.html')
    elif request.method == 'POST':
        user = request.POST.get('user')
        pwd = request.POST.get('pwd')
        if user == 'whw' and pwd == '123':
            return HttpResponse('OK!')
        else:
            return HttpResponse('ERROR!')

def get_y_m(request,m,y):
    print(y)
    print(type(y))#这里默认的是str类型
    return HttpResponse('y:%s;m:%s'%(y,m))


def get_year_month(request,year,month):
    print(year,minth)
    print(type(year),type(month))
    return HttpResponse(year,month)
</code></pre>

<p><strong>path的基本规则如下：</strong></p>
<ol>
<li>使用尖括号(&lt;&gt;)从url中捕获值。</li>
<li>捕获值中可以包含一个转化器类型（converter type），比如使用 捕获一个整数变量。</li>
<li>若果没有转化器，将匹配任何字符串，当然也包括了 / 字符。</li>
<li>无需添加前导斜杠。</li>
</ol>
<h3 id="path-converters">path converters</h3>
<p>这里就把它翻译成<code>path转换器</code>吧。</p>
<p><strong>5种默认转换器</strong></p>
<p>1、str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式 </p>
<p>2、int,匹配正整数，包含0。 #slug用的比较多——相当于匹配下面的字符串——省去了正则表达式 </p>
<p>3、slug,匹配字母、数字以及横杠、下划线组成的字符串。 </p>
<p>4、uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00）—— 注意不能用<code>?</code>，它是GET请求数据左右部分的分隔符！ </p>
<p>5、path,匹配任何非空字符串，包含了路径分隔符</p>
<p><strong>自定义转换器的使用</strong></p>
<p>对于一些复杂或者复用的需要，可以定义自己的转化器。转化器是一个类或接口，它的要求有三点：</p>
<pre><code class="python">1、regex 类属性，字符串类型
2、to_python(self, value) 方法，value是由类属性 regex 所匹配到的字符串，返回具体的Python变量值，以供Django传递到对应的视图函数中。
3、to_url(self, value) 方法，和 to_python 相反，value是一个具体的Python变量值，返回其字符串，通常用于url反向引用。
</code></pre>

<p><strong>一个自定义转换器的例子</strong></p>
<p>(1)在blog应用中，新建一个url_convert.py文件，这个文件新建一个类</p>
<p>注意这个类的名字可以随便取，但是类中的属性与方法名是固定的！</p>
<pre><code class="python">class FourDigitYearConverter:  
    #规则字符串
    regex = '[0-9]{4}'
    #to_python方法
    def to_python(self, value):  
        return int(value)
    #to_url方法——用于反向解析
    def to_url(self, value):  
        return '%04d' % value
</code></pre>

<p>(2)使用register_converter 将其注册到URL配置中</p>
<pre><code class="python">#在blog的url.py文件中注册：
from django.urls import register_converter, path  
#将写好的url_convert引入：
from blog import url_convert, views
#用yyyy做替换：      
register_converter(url_convert.FourDigitYearConverter, 'yyyy')  

from django.urls import path,re_path,register_converter
from blog import views,url_convert

register_converter(url_convert.four_year_to_int,'yyyy')

urlpatterns = [
    re_path('^login/$',views.login,name='LOGIN'),

    #有名分组+反向解析
    re_path('^articles/(?P&lt;y&gt;[0-9]{4})/(?P&lt;m&gt;[a-zA-Z]+)/$',views.get_y_m),

    path('articles/&lt;yyyy:year&gt;/&lt;yyyy:month&gt;',views.get_year_month),
    ]

#注意浏览器中要这样写：http://127.0.0.1:8000/blog/articles/1000/1234
#year跟month都是4位，因为规则是：regex = '[0-9]{4}'
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../视图系统/" class="btn btn-neutral float-right" title="02 视图系统">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../Django框架入门/" class="btn btn-neutral" title="Django框架入门"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../../Django框架入门/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../视图系统/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
